// -----------------------------------------------------------------------
// Arbiter with grant hold, and round-robin priority
// Generated by python script "arb_gen.py"
// -----------------------------------------------------------------------
module arbiter (
    input logic req0,
    input logic req1,
    input logic req2,
    input logic req3,
    input logic req4,
    input logic req5,
    input logic req6,
    input logic req7,
    input logic req8,
    output logic gnt0,
    output logic gnt1,
    output logic gnt2,
    output logic gnt3,
    output logic gnt4,
    output logic gnt5,
    output logic gnt6,
    output logic gnt7,
    output logic gnt8,
    input logic clk,
    input logic rst
);
    // Internal parameters and signals
    localparam integer WIDTH = 9;
    logic [WIDTH - 1:0] req, gnt;
    logic [WIDTH - 1:0] last, prio;
    logic [WIDTH*2 - 1:0] carry;
    wire [WIDTH - 1:0] tmp_gnt, hold;
    wire [WIDTH - 1:0] next_prio;
    wire any_hold;

    // Assignments of signals to arrays for internal use
    assign req = {req8,req7,req6,req5,req4,req3,req2,req1,req0};
    assign gnt0 = gnt[0];
    assign gnt1 = gnt[1];
    assign gnt2 = gnt[2];
    assign gnt3 = gnt[3];
    assign gnt4 = gnt[4];
    assign gnt5 = gnt[5];
    assign gnt6 = gnt[6];
    assign gnt7 = gnt[7];
    assign gnt8 = gnt[8];

    // Carry and (temporary) Grant logic
    always_comb begin // Avoid cyclic carry chain, double the arbiter slices and OR outputs
        carry[0] = 0; // Expressing this logic in a for-loop will not work correctly for some reason
        carry[1] = (~req[0] & (carry[0] | prio[0]));
        carry[2] = (~req[1] & (carry[1] | prio[1]));
        carry[3] = (~req[2] & (carry[2] | prio[2]));
        carry[4] = (~req[3] & (carry[3] | prio[3]));
        carry[5] = (~req[4] & (carry[4] | prio[4]));
        carry[6] = (~req[5] & (carry[5] | prio[5]));
        carry[7] = (~req[6] & (carry[6] | prio[6]));
        carry[8] = (~req[7] & (carry[7] | prio[7]));
        carry[9] = (~req[8] & (carry[8] | prio[8]));
        carry[10] = (~req[0] & (carry[9] | prio[0]));
        carry[11] = (~req[1] & (carry[10] | prio[1]));
        carry[12] = (~req[2] & (carry[11] | prio[2]));
        carry[13] = (~req[3] & (carry[12] | prio[3]));
        carry[14] = (~req[4] & (carry[13] | prio[4]));
        carry[15] = (~req[5] & (carry[14] | prio[5]));
        carry[16] = (~req[6] & (carry[15] | prio[6]));
        carry[17] = (~req[7] & (carry[16] | prio[7]));
    end
    assign tmp_gnt = (req & (carry[WIDTH*2-1:WIDTH] | prio)) | (req & (carry[WIDTH-1:0] | prio));

    // Hold logic
    assign hold = req & last;
    assign any_hold = |hold;
    assign gnt = any_hold ? hold : tmp_gnt;

    // Round-Robin Next priority
    assign next_prio = |gnt ? {gnt[WIDTH-2:0], gnt[WIDTH-1]} : prio;

    // Sequential
    always_ff @(posedge clk or posedge rst) begin
        if(rst) begin
            last <= 0;
            prio <= 1; // Reset priority to ..01
        end else begin
            last <= gnt; // Register for last
            prio <= next_prio; // Register for priority
        end
    end

endmodule
