############################ Arbiter generator ############################
# Generates an arbiter with hold and round-robin priority
# Usage: python3 arb_gen.py <width>
# The arbiter will be saved in rtl/arbiter.sv (and overwrite existing file)
#
# This generator exists because of inconsistency in the
# systemverilog (2009) standard and the simulator (Vivado 2022.2)
###########################################################################
import os
from sys import argv

filename = os.path.join(os.path.realpath(os.path.dirname(__file__)),"../rtl/arbiter.sv")

width = int(argv[1]) # Get width of the arbiter

m_txt_1 = """// -----------------------------------------------------------------------
// Arbiter with grant hold, and round-robin priority
// Generated by python script "arb_gen.py"
// -----------------------------------------------------------------------
module arbiter (
"""
req_txt = "    input logic req{},\n"
gnt_txt = "    output logic gnt{},\n"
m_txt_2 = """    input logic clk,
    input logic rst
);
    // Internal parameters and signals
    localparam integer WIDTH = {};
"""
m_txt_3 = """    logic [WIDTH - 1:0] req, gnt;
    logic [WIDTH - 1:0] last, prio;
    logic [WIDTH*2 - 1:0] carry;
    wire [WIDTH - 1:0] tmp_gnt, hold;
    wire [WIDTH - 1:0] next_prio;
    wire any_hold;

    // Assignments of signals to arrays for internal use
    assign req = {{{0}}};
"""
gnt_assign_txt = "    assign gnt{} = gnt[{}];\n"
m_txt_4 = """
    // Carry and (temporary) Grant logic
    always_comb begin // Avoid cyclic carry chain, double the arbiter slices and OR outputs
        carry[0] = 0; // Expressing this logic in a for-loop will not work correctly for some reason
"""
carry_txt = "        carry[{}] = (~req[{}] & (carry[{}] | prio[{}]));\n"
m_txt_5 = """    end
    assign tmp_gnt = (req & (carry[WIDTH*2-1:WIDTH] | prio)) | (req & (carry[WIDTH-1:0] | prio));

    // Hold logic
    assign hold = req & last;
    assign any_hold = |hold;
    assign gnt = any_hold ? hold : tmp_gnt;

    // Round-Robin Next priority
    assign next_prio = |gnt ? {gnt[WIDTH-2:0], gnt[WIDTH-1]} : prio;

    // Sequential
    always_ff @(posedge clk or posedge rst) begin
        if(rst) begin
            last <= 0;
            prio <= 1; // Reset priority to ..01
        end else begin
            last <= gnt; // Register for last
            prio <= next_prio; // Register for priority
        end
    end

endmodule
"""

with open(filename, "w") as file:
    file.write(m_txt_1)

    for i in range(width):
        file.write(req_txt.format(i))

    cat_r_txt = ""
    cat_g_txt = ""

    for i in range(width):
        file.write(gnt_txt.format(i))
        cat_r_txt  += "req{}".format(width-1-i)
        if i != width-1:
            cat_r_txt += ","
    
    file.write(m_txt_2.format(width))
    file.write(m_txt_3.format(cat_r_txt))
    
    for i in range(width):
        file.write(gnt_assign_txt.format(i,i))
    
    file.write(m_txt_4)

    for i in range(width*2-1):
        file.write(carry_txt.format(i+1,i%width,i,i%width))
    
    file.write(m_txt_5)
